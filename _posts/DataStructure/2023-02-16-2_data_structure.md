---
layout: single
title: "02.순차적 자료구조: 배열과 리스트"
categories: 
  - DataStructure
  - CS
---

# 2. 순차적 자료구조: 배열과 리스트

## 배열(array) vs 리스트(list)

- 가장 기본적인 순차적인(sequential) 자료구조
- c언어에서의 배열(array)
    - ex) int A[4] = {2,4,0,5};
    - A[0], A[1], A[2], A[3] 안에 2,4,0,5 자체가 저장되어 있다.
    c언어에서 int 자료형 한개는 4byte로 구성되어 있다. 그리고 바이트 별로 주소가 있기 때문에 배열에 해당하는 A 변수에는 A[0]의 첫번째 바이트의 주소가 저장되어 있다. 예를 들어 100이 저장되어 있으면 A[0]의 첫번째 바이트 주소는 100이 되고 A[1]은 104, A[2]는 108, A[3]은 112의 바이트 주소로 시작한다.
    - 인덱스를 통해서 배열의 특정 위치에 있는 값을 상수 시간 내에 읽고 쓸 수 있는 자료구조를 배열이라 한다.
- python에서의 리스트(list)
    - 배열처럼 index로 값을 읽고 쓸 수 있지만 더 많은 기능을 제공한다.
    - ex) A = [2,4,0,5]
    - 배열에서는 원소 자체에 실제값이 저장되어 있지만 리스트에서는 2,4,0,5 객체가 각각이 다른 메모리에 저장되어 있고 각 원소에 각 객체를 가리키는 주소가 저장되어 있다.
    - A[2] = A[2]+1을 실행 시 배열에서는 A[2] 자체 값이 0에서 1로 바뀐다. 하지만 리스트에서는 원래 A[2]가 가리키는 0 객체는 변화가 없고 1이라는 새로운 객체가 메모리 어딘가에 새로 생성된 후 A[2]에는 새로 생긴 1 객체를 가리키는 주소가 저장된다.
    - append, pop, insert, remove, index, count 등 여러 함수 제공
    - 리스트는 용량을 자동으로 조절하는  dynamic array이다.
    
    ```python
    #list에서 append 작동 시 용량의 변화를 자동으로 조정하는 내부 구조 수도코드로
    A.append(x):
    	if A.n < A.capacity: # n(현재 저장된 값의 개수)보다 용량이 작으면
    		A[n] = x  
    		A.n = n+1
    	else:
    		B = A.capacity*2
    		for i in range(n):
    			B[i] = A[i]
    		del A
    		A = B
    		A[n] = x
    		A.n = n+1
    ```
    

## 순차적 자료구조의 종류

- 배열, 리스트
    - index로 임의의 원소를 읽고 쓸 수 있다.
    - index로 접근 시 O(1) 소요
    - 삽입, 삭제는 맨 뒤 원소의 경우 O(1) 소요되지만 최악의 경우 O(n) 소요될 수 있다. (A[0]에 삽입하거나 A[0]을 삭제 시 오른쪽 원소들을 왼쪽으로 이동시키는 연산이 필요하기 때문)
- stack, queue, dequeue
    - 제한된 접근(삽입, 삭제)만 허용
    - stack: LIFO(Last In First Out)
    - queue: FIFO(First In First Out)
    - dequeue: stack + queue
- linked list
    - 연속되지 않은 메모리(독립적인 메모리)에 저장된 각각의 객체가 해당값과 다음 객체의 주소를 저장되어 연결되어있다.
    - 인덱스로 접근 x