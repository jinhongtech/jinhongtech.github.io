---
layout: single
title: "알고리즘 시간복잡도"
categories: 
  - DA
---

# 알고리즘 시간복잡도

## 자료구조와 알고리즘 성능

- 자료구조: 저장공간(memory)에서 데이터를 효율적으로 관리하기 위한 데이터의 구조
    - ex) 변수, 배열, 리스트 …
- 알고리즘: 자료구조에 저장된 데이터를 입력해서 유한한 횟수의 연산들을 활용해 어떤 문제를 푸는 논리적 절차
- 자료구조 알고리즘 성능 측정의 문제점
    1. 개개인의 HW/SW 환경이 다르다.
    2. 다양한 크기의 입력이 존재한다.
- 해결법 : 기본연산을 1단위시간에 할 수 있는 가상컴퓨터(virtual machine)에서 알고리즘 수행 시간을 측정
- 기본연산(단위시간에 수행되는 연산)
    - 배정, 대입, 복사
    - 산술: +, -, *, / 등
    - 비교: >, ≥, <, ≤, ==, ≠
    - 논리: AND, OR, NOT
    - 비트: bit-AND, OR, NOT

## 시간 복잡도(time complexity)

- 알고리즘 수행시간 측정 방식
    - 모든 입력에 대해 기본연산 횟수를 더한 후 평균 → 정확하지만 모든 알고리즘을 계산하는 것은 현실적으로 불가능
    - 가장 안좋은 입력(기본연산 횟수를 최대화 하는)에 대한 기본 연산 횟수 측정: worstcase time complexity → **어떤 입력에 대해서 도 W.T.C보다 수행시간이 크지 않다**

### 알고리즘 수행시간 = 최악의 입력에 대한 기본연산 횟수

```python
# ex1
def sum(A,n):
	sum = 0					# 대입 연산1회

	for i in range(0,n):       		# i=0, j=0~n-1
		for j in range(i,n):    	# i=1, j=1~n-1
						# …
						# i=n-1, j=n-1
						# for문의 반복 횟수 n+(n-1)+...+1 = n(n-1)/2

			sum += A[i]*A[j]  	# for문 안에서의 연산
						# sum = sum + A[i]*A[j]  대입,더하기,곱하기 연산3회
	return sum
```

**∴ 알고리즘 수행시간 T(n) =  1+ 3*{n(n+1)/2}** 

### Big-O 표기법

- 수행시간을 입력 n에 대한 알고리즘 수행시간에서 수행시간의 증가율을 의미하는 n의 최고 차항만(계수는 생략)으로 표기하는 방법

```python
# ex2
def number_of_bits(n):
	count = 0		# 입력 연산 1회

	while n>0:		# n -> n//2 -> n//(2^2) -> ... -> n//(2^count)
				# 홀수나 짝수가 1회의 반복을 마치고 나면 짝수로 변한된다.
				# n/(2^count) = 1 이므로 count = log2(n) 이 된다.

		n = n//2        # 연산 2회
		count +=1       # 연산 2회
	return count
```

**∴ T(n) = 1 + 4log2(n)       
이 경우 상수 1, 로그의 계수 4, 로그의 밑 2를 생략해서 Big-O 표기법으로 O(log n)으로 표기할 수 있다.**

- Big-O 표기법의 종류
    - O(1) < O(log n) < O(n) < O(n* log n) <  O(n^2) < O(n^3) < O(2^n) < O(n!)
