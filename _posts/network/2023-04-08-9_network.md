---
layout: single
title: "[네트워크 기초] 09.연결지향형 TCP 프로토콜"
categories: 
  - Network
  - CS
---

## TCP 프로토콜

### TCP가 하는일

- 전송 제어 프로토콜(Transmission Control Protocol)은 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 통신을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
- 안정성이 필요하지 않은 프로그램은 TCP 대신 UDP를 사용한다.
- UDP 보다 안전하지만 느리다.

### TCP 프로토콜의 구조


<img src="/images/network/9.tcp1.png">

| 구조 | 설명 |
| --- | --- |
| Source Port | 출발지 포트번호 |
| Destination Port | 목적지 포트번호 |
| Sequence Number | 서로의 상태를 동기화할 때 사용하는 값(보안 시 중요) |
| Acknowledgement Number | 서로의 상태를 동기화할 때 사용하는 값(보안 시 중요) |
| Offset | 헤더의 길이를 4로 나눈 값 (기존에 사용했던 offset 개념과 다름) |
| Reserved | 예약된 필드(사용하지 않는 필드) |
| TCP Flags | 상대방과 연결하면서 상대방과의 상태를 계속 확인하는데 이 때 데이터의 형태. 아래에서 추가 설명 |
| Window | 상대방과 연결돼서 데이터를 보낼 때 얼마만큼 더 보낼지(남아있는 TCP buffer 공간) |
| Checksum | 오류가 있는지 확인하는 값 |
| Urgent Pointer | 긴급 데이터를 포함하고 있는 경우(TCP 플래그가 U) 사용되는 필드로 긴급 데이터의 위치값 |

## TCP 플래그

### TCP 플래그의 종류

| 종류 | 설명 |
| --- | --- |
| U(Urgent) | 긴급 비트, 보내는 데이터에 우선순위가 높은 데이터가 포함되어 있다. (Urgent Pointer 필트와 같이 사용됨) |
| A(ACK) | 승인 비트, 승인할 때 사용하는 플래그 |
| P(PUSH) | 밀어넣기 비트, TCP 버퍼가 일정 크기만큼 쌓여야 패킷을 추가적으로 전송할 수 있는데 이와 상관없이 데이터를 밀어넣겠다는 플래그 |
| R(RESET) | 초기화 비트, 상대방과 연결된 상태에서 문제가 발생해서 리셋하기 위한 플래그 |
| S(SYN) | 동기화 비트, 상대방과 연결을 시작할 때 무조건 사용하는 플래그 |
| F(FIN) | 종료 비트, 연결을 종료할 때 사용하는 플래그 |

## TCP를 이용한 통신과정

### 연결 수립 과정

- TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정
- 3Way Handshake
    
    <img src="/images/network/9.tcp2.png">

    
    1. 클라이언트가 서버에게 요청 패킷 전송
        1. TCP flag는 SYN으로 설정
        2. Sequence Number: 초기에 랜덤한 값으로 설정
        3. Acknowledgement Number: 초기에 랜덤한 값으로 설정
    2. 서버가 클라이언트의 요청을 받아들이는 패킷 전송
        1. TCP flag는 SYN과 ACK 설정
        2. A: 1번의 S에서 +1(단순히 연결하기 위한 과정이라 페이로드가 없기 때문)
        3. S: 서버가 랜덤한 값으로 설정
    3. 클라이언트는 이를 최종적으로 수락하는 패킷 전송
        1. TCP flag는 ACK 설정
        2. A: 2번의 S에서 +1
        3. S: 서버와 이미 동기화된 상태이므로 2번의 A 값을 사용
    - 세션 하이잭킹: 클라이언트와 서버와의 연결 수립 과정에서 계산된 Sequence number와 Acknowledgement number를 클라이언트가 아닌 다른 사람이 계산해서 서버에 보내 서버와의 연결을 뺏어오는 행위

### 데이터 송수신 과정

- TCP 데이터 통신에서 페이로드를 포함한 패킷을 주고 받을 때의 규칙
    1. 보낸 쪽에서 또 보낼 때는 SEQ번호와 ACK번호가 그대로다.
    2. 받는 쪽에서 SEQ번호는 받은 ACK번호가 된다.
    3. 받는 쪽에서 ACK번호는 받은 SEQ번호 + 데이터의 크기(연결 수립과정에서는 데이터가 없으므로 1로 설정했었다.)
- 과정
    
    <img src="/images/network/9.tcp3.png">

    
    1. 연결 수립과정 이후에 클라이언트가 웹서버에 데이터를 요청
        1. 연결 수립 과정 마지막에 클라이언트가 보내고 다시 보내는 것이므로 SEQ와 ACK 번호 그대로
    2. 서버가 클라이언트에 응답
        1. SEQ번호: 받은 ACK번호인 2001
        2. ACK번호: 101(받은 SEQ번호) + 100(데이터 길이)
    3. 클라이언트가 잘 받았다고 응답
        1. SEQ번호: 받은 ACK번호인 201
        2. ACK번호: 2001(받은 SEQ번호) + 500(데이터 길이)

## TCP 상태전이도

### TCP 연결 상태의 변화

<img src="/images/network/9.tcp4.png">


- 실선(클라이언트의 상태변화), 점선(서버의 상태변화)
- LISTEN: 포트번호를 열어놓고 있는 상태(클라이언트가 요청 시 서버가 응답할 수 있는 상태)
- ESTABLISHED: 연결이 서로 수립된 상태
- 3Way Handshake에서:
    1. 서버가 Listen상태에서 클라이언트가 요청 패킷을 전송해서 서버가 패킷을 받음
        1. 클라이언드 SYN_SENT 상태, 서버는 SYN_RCVD 상태
    2. 서버가 요청 응답 패킷 전송해서 클라이언트가 받음
        1. 1-a 상태 유지
    3. 클라이언트가 최종 수락하는 패킷을 전송해서 서버가 받음
        1. 클라이언트와 서버 모두 ESTABLISHED 상태