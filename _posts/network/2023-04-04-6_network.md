---
layout: single
title: "06.멀리 있는 컴퓨터끼리의 통신 - IP 프로토콜"
categories: 
  - NW
---

## IPv4 프로토콜

- 네트워크 상에서 데이터를 교환하기 위한 프로토콜
- 데이터가 정확하게 전달될 것을 보장하지 않는다.

<img src="/images/network/6.ip1.png" width="100%" height="100%">


| 구조 | 설명|
| --- | --- |
| Version | IP 프로토콜의 버전 →  IPv4이므로 16진수 4 |
| IHL(Header Length) | 20 ~ 60 (최소 20Bytes ~ IP Options에 따라 60Bytes까지) 4bits 로 20~60을 표현할 수 없으므로 4로 나눈 값을 16진수로 나타낸다. |
| Type of Service (TOS) | 과거에 데이터의 형식을 나타낼 때 사용했으나 현재는 사용하지 않아서 0 0 으로 비워둔다. |
| Total Length | 헤더의 길이가 아니라 상위 계층부터 인캡슐레이션된 패킷의 전체 길이 |
| Identification | 패킷을 전송할 때 패킷을 조각화하여 전송하는데 이 때 Identification 값을 통해서 같은 패킷인지 확인하여 다시 하나로 합친다.  |
| IP Flags | x: 거의 안씀 → 0으로 설정<br/>  D: Don’t fragmentation(쪼개지 않고 보냄) → 이게 세팅되면 전송 안됨 → 0으로 설정<br/> M: More fragmentation → 쪼개서 보냈으니까 조각이 남아있다.<br/> [0 0 0 이면 한번에 0 0 1 이면 조각화] |
| Fragment Offset | 조각화된 패킷의 순서를 기록한 정보 |
| Time To Live (TTL) | IPv4는 데이터가 정확하게 전달될 것을 보장하지 않기 때문에 비정상적인 패킷이 잘못 축적될 경우 문제가 발생할 수 있다. 이를 방지하기 위해 TTL을 설정하여 패킷의 수명을 설정한다.[10으로 설정했을 때 하나의 네트워크 장비를 지날 때 1씩 줄어든다. 0이 되면 패킷을 버린다.] <br/> TTL을 통해 상대방의 운영체제를 파악할 수 있다(운영체제마다 TTL 값이 다름). |
| Protocol | 상위 프로토콜의 종류 [0 1 (ICMP), 0 6 (TCP), 1 0 (UDP)] |
| Header Checksum | 이 헤더가 오류가 있는지 없는지 확인하는 값 |
| Source Address | 출발지 IP 주소 |
| Destination Address | 도착지 IP 주소 |



## ICMP(Internet Control Message Protocol) 프로토콜

- 주로 네트워크 장비의 운영체제에서 오류 메세지를 전송 받는데 사용된다.
- 프로토콜 구조의 Type과 Code를 통해 오류 메세지를 전송 받는다.
<img src="/images/network/6.ip2.png" width="100%" height="100%">

| 구조 | 설명 |
| --- | --- |
| Type | 대분류<br/> [0(echo reply 통신확인-응답), 8(echo 통신확인-요청), 3(destination unreachable 오류-목적지까지 가질 못함), 11(time exceded 오류-목적지까지 갔는데 응답을 못받음), 5(redirect 원격지에 있는 상대방의 라우팅 테이블을 ICMP로 수정할 때 사용)] |
| Code | 소분류 |
| Checksum | 헤더에 오류가 있는지 없는지 확인하는 값(컴퓨터가 자동으로 계산) |

## 라우팅 테이블

패킷을 어디로 보내야 하는지 설정되어 있는 테이블

## 다른 네트워크와 통신 과정

A가 B와 통신하기 위한 과정
    <img src="/images/network/6.ip3.png" width="100%" height="100%">
<ol>
<li>A는 B의 네트워크 대역이 라우팅 테이블에 있어야 통신할 수 있으므로 A가 자신의 라우팅 테이블을 확인한다.</li>
    <ol type='a'>
    <li>A의 라우팅 테이블에 B의 네트워크 대역 ‘192.168.20.0/24’이 있는지 확인 <br/>(192.168.20.0/24 의 /24는 IP 주소 32bits 중 24bits를 고정하고 나머지 8bits만 바뀔 수 있다는 뜻이다. 즉, 192.168.20.0 ~ 192.168.20.255 네트워크 대역을 의미)</li>
    <li>라우팅 테이블의 192.168.20.0/24 → 192.168.10.1 은 192.168.20.0/24를 가기 위해서 192.168.10.1로 가야한다는 것을 의미한다.</li>
    </ol>
<li>A는 통신을 확인하기 위해 패킷을 생성한다.</li>
    <ol type='a'>
    <li>ICMP 요청 프로토콜: 요청이므로 ICMP Type을 8로 설정</li>
    <li>IPv4 프로토콜: 출발지 주소에 A의 IP주소, 도착지 주소에 B의 IP주소</li>
    <li>Ethernet 프로토콜: 이더넷 프로토콜은 같은 네트워크 대역에서 통신하는 프로토콜이고 A의 라우팅 테이블에 192.168.20.0/24로 가기 위해서 192.168.10.1을 거쳐야 한다고 표기되어있다. 그러므로 출발지 주소는 A의 MAC주소이고 도착지 주소는 C(게이트 웨이)의 맥주소이다.</li>
    </ol>
<li>스위칭 허브는 패킷의 2계층 Ethernet 프로토콜을 확인하고 C에게 전송</li>
<li>C가 패킷을 전송받는다.</li>
    <ol type='a'>
    <li>Ethernet 확인: 목적지 주소가 C의 MAC주소와 동일 확인</li>
    <li>IPv4 확인: 목적지 주소가 C의 IP주소와 다름</li>
    <li>라우팅 테이블 확인: 192.168.20.0/24로 가기 위해선 192.168.30.2(라우터 E)로 가야함</li>
    <li>Ethernet 프로토콜 재생성: 출발지 주소를 C의 MAC 주소로, 도착지 주소를 E의 MAC 주소로 작성</li>
    <li>E로 전송</li>
    </ol>
<li>E가 패킷을 전송받는다.</li>
    <ol type='a'>
    <li>4와 동일한 과정으로 D로 전송</li>
    </ol>
<li>D가 패킷을 전송받는다.</li>
    <ol type='a'>
    <li>Ethernet 확인 → IPv4 확인 → Ethernet 재생성 → B로 전송</li>
    </ol>
<li>B가 패킷을 전송받는다.</li>
    <ol type='a'>
    <li>Ethernet 확인 → IPv4 확인 → ICMP 응답 확인</li>
    <li>ICMP 요청 프로토콜 생성: ICMP Type을 0으로 설정</li>
    <li>IPv4 프로토콜 생성: 출발지 주소 B의 IP주소, 목적지 주소 A의 IP주소</li>
    <li>Ethernet 프로토콜 생성: 출발지 주소 B의 MAC주소, 목적지 주소 D의 IP주소</li>
    </ol>
<li>1~7의 과정과 동일하게 A로 패킷 전송 후 A는 B와 통신되는 것을 알 수 있다.</li>
    <ul>
    <li>만약 같은 네트워크 대역에서 패킷을 전송할 때 MAC 주소를 모른다면 ARP 프로토콜을 통해 MAC 주소를 알아내는 과정이 추가된다.</li>
    </ul>
</ol>

## IPv4의 조각화

### 조각화
- MTU(Maximum Transmission Unit): 데이터의 최대 전송 단위(\\\IPv4를 인캡슐레이션해서 보낼 때 네트워크 장비마다 값이 설정되어 있다.)
- 조각화: MTU보다 큰 패킷을 전송하기 위해서 여러 개의 작은 패킷으로 쪼개는 것
    - 패킷이 전달되는 과정에서 통과하는 각 라우터마다 전송에 적합한 프레임(2계층 PDU)으로 변환이 필요
    - 일반적으로, 조각화되면 목적지에 도달할 때까지 재조립되지 않는다.
    - IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 조각화 가능
    - IPv6에서는 발신지에서만 조각화 가능

### 조각화하는 과정
<img src="/images/network/6.ip4.png" width="100%" height="100%">

1. IPv4 헤더의 길이를 20바이트라고 한다면 전체 패킷 용량은 12000바이트
2. 첫 조각화에서 MTU가 3300바이트이므로 조각화된 패킷의 IPv4 헤더와 데이터의 용량 합이 3300바이트 이하여야 한다.
3. 초각화된 패킷들은 전부 IPv4의 Identification값이 동일해야한다.
4. offset은 데이터 시작점에서부터의 거리(데이터의 용량)을 8로 나눈 값을 사용
5. 첫 번째 패킷 조각에서 MF(More Fragmentation)은 1로 설정해서 남아있는 조각이 있다는 것을 알려주고 Offset은 0으로 설정하여 첫 번째 패킷 조각임을 알려준다.
6. 두 번째 패킷 조각도 MF를 1로 설정해준다. Offset은 3280/8 = 410
7. 세 번째 패킷 조각도 MF를 1로 설정해준다. Offset은 3280*2/8 = 820
8. 마지막 패킷 조각은 MF를 0으로 설정해서 더 이상 남아있지 않음을 알려준다. offset은 3280*3/8 = 1230


### 추가 설명
- IPv4까지 인캡슐레이션된 패킷이 MTU를 초과했을 경우 전송이 안됨

    <img src="/images/network/6.ip5.png" width="100%" height="100%">

- 데이터를 조각화 예시

    <img src="/images/network/6.ip6.png" width="100%" height="100%">

    1. 2000바이트의 데이터를 1480바이트, 520바이트 데이터로 쪼갠다.
    2. 1480바이트 데이터에 IPv4 20바이트가 붙는다. 520바이트 데이터에 ICMP 28바이트 IPv4 20바이트가 붙는다.
    3. 이 때 왼쪽과 오른쪽의 IPv4 프로토콜 안의 값들이 다르다.
    
        |  | 1500바이트 패킷의 IPv4 | 548바이트 패킷의 IPv4 |
        | --- | --- | --- |
        | Total length | 1500 | 548 |
        | Identification | 동일 | 동일 |
        | MF(more fragment) | 1  | 0 |
        | Offset | 0 | 1480/8 = 185 |

- MTU로 걸러지고 난 후에 Ethernet 프로토콜이 붙는다.